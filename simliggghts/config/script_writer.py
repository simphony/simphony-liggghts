from simphony.core.cuba import CUBA

from .pair_style import PairStyle
from ..cuba_extension import CUBAExtension
from ..common import globals


class ConfigurationError(RuntimeError):
    pass


class ScriptWriter(object):
    """ Writer of a LIGGGHTS-commands script

    The ScriptWriter generates a series of LIGGGHTS commands
    (that make up a LIGGGHTS-input script).

    The command script generated by this class can be passed to
    a LIGGGHTS executable as a file or string.

    TODO: script can be passed to the library interface of LIGGGHTS or
    individual commands generated by this script can be passed
    "one by one" to the library interface of LIGGGHTS

    Parameters
    ----------
    atom_style: str
        atom_style

    """

    def __init__(self, atom_style):
        self._atom_style = atom_style

    @staticmethod
    def check_configuration_CM(CM):
        return _check_configuration_CM(CM)

    @staticmethod
    def check_configuration_SP(SP):
        return _check_configuration_SP(SP)

    @staticmethod
    def check_configuration_BC(BC):
        return _check_configuration_BC(BC)

    def get_configuration(self, BC, CM, SP, input_data_file, output_data_file):
        """ Return configuration command-script

        Parameters
        ----------
        BC : DataContainer
            container of attributes related to the boundary conditions
        CM : DataContainer
            container of attributes related to the computational method
        SP : DataContainer
            container of attributes related to the system parameters/conditions
        input_data_file: string
            name of data file to be read at beginning of run (input)
        output_data_file: string
            name of data file to be written after run (output)

        Returns
        -------
        command script - string
            lines of a LIGGGHTS command script

        """

        result = "# Control file generated by SimPhoNy\n"

        result += "dimension 3\n"

        result += ScriptWriter.get_boundary(BC)

        result += self.get_initial_setup()

        # TODO hard-coding certain values for DEM example
        result += DEM_DUMMY

        result += ScriptWriter.get_pair_style(SP)

        if input_data_file:
            result += READ_DATA.format(INPUT_DATAFILE=input_data_file)

        result += ScriptWriter.get_box_planes(SP)

        result += ScriptWriter.get_fix(CM)

        # result += "dump 1 all custom 100 test.flow id type x y z vx vy"

        result += ScriptWriter.get_run(CM)

        if output_data_file:
            result += WRITE_DATA.format(OUTPUT_DATAFILE=output_data_file)

        return result

    @staticmethod
    def get_run(CM):
        """ Return run command-script

        """
        number_steps = CM[CUBA.NUMBER_OF_TIME_STEPS]
        time_step = CM[CUBA.TIME_STEP]
        return CONFIGURATION_RUN.format(NUMBER_STEPS=number_steps,
                                        TIME_STEP=time_step)

    @staticmethod
    def get_pair_style(SP):
        """ Return pair_coeff command-script

        """
        # TODO this should be change once this class
        # keeps track of states
        pair_style = PairStyle(SP)
        return pair_style.get_global_config()

    @staticmethod
    def get_pair_style_liggghts(SP):
        """ Return pair_style command-script

        """
        # TODO this should be change once this class
        # keeps track of states
        return _get_pair_style_liggghts(SP)

    @staticmethod
    def get_pair_coeff(SP):
        """ Return pair_coeff command-script

        """
        # TODO this should be change once this class
        # keeps track of states
        pair_style = PairStyle(SP)
        return pair_style.get_pair_coeffs()

    @staticmethod
    def get_boundary(BC, change_existing_boundary=False):
        """ get liggghts commands related to boundary conditions (BC)

        Parameters:
        ----------
        BC : DataContainer
            container of attributes related to the boundary conditions
        change_existing_boundary : boolean
            if true then return liggghts commands that change existing boundary
            conditions. if false, then return liggghts commands that set the
            boundary conditions
        """
        return _get_boundary(BC, change_existing_boundary)

    @staticmethod
    def get_fixed_groups(BC):
        """ get liggghts commands to fix particles with specific type

        Parameters:
        ----------
        BC : DataContainer
            container of attributes related to the boundary conditions
        """
        return _get_fixed_groups(BC)

    @staticmethod
    def get_box_planes(SP, BC):
        """ Using CUBA.BOX_VECTORS and CUBA.BOX_ORIGIN, return the
        string used by LIGGGHTS to define the simulation box in
        the LIGGGHTS data file or as a command.

        Parameters:
        ----------
        SP : DataContainer
            container of attributes related to the state parameters
        BC : DataContainer
            container of attributes related to the boundary conditions
        """
        return _get_box_planes(SP, BC)

    @staticmethod
    def get_material_data(SP):
        """ Using provided material parameters, return the
        string used by LIGGGHTS to define the material data.

        Parameters:
        ----------
        SP : DataContainer
            container of attributes related to the state parameters
        """
        return _get_material_data(SP)

    @staticmethod
    def get_ext_forces(self):
        """ Provide the infrastructure to treat externally applied forces
        on each particle (e.g. gravity, drag). Return several LIGGGHTS strings
        that are required for further force value exchange via extract_fix in
        particle_data_cache.

        Parameters:
        ----------
        """
        return _get_ext_forces(self)

    def get_initial_setup(self):
        return """
atom_style  granular
atom_modify     map array sort 0 0.0
neighbor    0.1e-3 bin
neigh_modify  delay 0
"""


def _check_configuration_CM(CM):
    """ Check if everything is configured correctly

    Raises
    ------
    ConfigurationError
        if anything is wrong with the configuration
    """
    cm_requirements = [CUBA.NUMBER_OF_TIME_STEPS,
                       CUBA.TIME_STEP]

    missing = [str(req) for req in cm_requirements
               if req not in CM.keys()]

    msg = ""
    if missing:
        msg = "Problem with CM component. "
        msg += "Missing: " + ', '.join(missing)

    if msg:
        # TODO throw unique exception that
        # users can catch and then try to fix
        # their configuration
        raise ConfigurationError(msg)


def _check_configuration_SP(SP):
    """ Check if everything is configured correctly

    Raises
    ------
    ConfigurationError
        if anything is wrong with the configuration
    """

    # All required parameters provided?
    sp_requirements = [CUBAExtension.BOX_ORIGIN,
                       CUBAExtension.BOX_VECTORS,
                       CUBA.YOUNG_MODULUS,
                       CUBA.POISSON_RATIO,
                       CUBA.RESTITUTION_COEFFICIENT,
                       CUBA.FRICTION_COEFFICIENT]

    if CUBAExtension.PAIR_POTENTIALS in SP:
        if "cohesion" in SP[CUBAExtension.PAIR_POTENTIALS]:
            sp_requirements.append(CUBA.COHESION_ENERGY_DENSITY)

    missing = [str(req) for req in sp_requirements
               if req not in SP.keys()]

    msg = ""
    if missing:
        msg = "Problem with SP component. "
        msg += "Missing: " + ', '.join(missing)

    if msg:
        # TODO throw unique exception that
        # users can catch and then try to fix
        # their configuration
        raise ConfigurationError(msg)

    # Correct format?
    if type(SP[CUBA.YOUNG_MODULUS]) is not list:
        msg = "YOUNG_MODULUS must be given as list"
        raise ConfigurationError(msg)
    if type(SP[CUBA.POISSON_RATIO]) is not list:
        msg = "POISSON_RATIO must be given as list"
        raise ConfigurationError(msg)
    if type(SP[CUBA.RESTITUTION_COEFFICIENT]) is not list:
        msg = "RESTITUTION_COEFFICIENT must be given as list"
        raise ConfigurationError(msg)
    if type(SP[CUBA.FRICTION_COEFFICIENT]) is not list:
        msg = "FRICTION_COEFFICIENT must be given as list"
        raise ConfigurationError(msg)
    if CUBAExtension.PAIR_POTENTIALS in SP:
        if "cohesion" in SP[CUBAExtension.PAIR_POTENTIALS]:
            if type(SP[CUBA.COHESION_ENERGY_DENSITY]) is not list:
                msg = "COHESION_ENERGY_DENSITY must be given as list"
                raise ConfigurationError(msg)

    # Each attribute defined for each material?
    if len(SP[CUBA.YOUNG_MODULUS]) != globals.MAX_NUMBER_TYPES:
        msg = "Need Youngs modulus for {} materials. ".\
            format(globals.MAX_NUMBER_TYPES)
        msg += "Only found {} entry.".format(len(SP[CUBA.YOUNG_MODULUS]))
        raise ConfigurationError(msg)
    if len(SP[CUBA.POISSON_RATIO]) != globals.MAX_NUMBER_TYPES:
        msg = "Need Poisson ratio for {} materials. ".\
            format(globals.MAX_NUMBER_TYPES)
        msg += "Only found {} entry.".format(len(SP[CUBA.POISSON_RATIO]))
        raise ConfigurationError(msg)
    if len(SP[CUBA.RESTITUTION_COEFFICIENT]) != (globals.MAX_NUMBER_TYPES *
                                                 globals.MAX_NUMBER_TYPES):
        msg = "Need restitution coefficient for {} materials. ".\
            format(globals.MAX_NUMBER_TYPES)
        msg += "Only found {} entries, but {} are required.".\
            format(len(SP[CUBA.RESTITUTION_COEFFICIENT]),
                   globals.MAX_NUMBER_TYPES * globals.MAX_NUMBER_TYPES)
        raise ConfigurationError(msg)
    if len(SP[CUBA.FRICTION_COEFFICIENT]) != (globals.MAX_NUMBER_TYPES *
                                              globals.MAX_NUMBER_TYPES):
        msg = "Need friction coefficient for {} materials. ".\
            format(globals.MAX_NUMBER_TYPES)
        msg += "Only found {} entries, but {} are required.".\
            format(len(SP[CUBA.FRICTION_COEFFICIENT]),
                   globals.MAX_NUMBER_TYPES * globals.MAX_NUMBER_TYPES)
        raise ConfigurationError(msg)
    if CUBAExtension.PAIR_POTENTIALS in SP:
        if "cohesion" in SP[CUBAExtension.PAIR_POTENTIALS]:
            if len(SP[CUBA.COHESION_ENERGY_DENSITY]) !=\
                (globals.MAX_NUMBER_TYPES *
                 globals.MAX_NUMBER_TYPES):
                msg = "Need cohesion energy density for {} materials. ".\
                    format(globals.MAX_NUMBER_TYPES)
                msg += "Only found {} entries, but {} are required.".\
                    format(len(SP[CUBA.COHESION_ENERGY_DENSITY]),
                           globals.MAX_NUMBER_TYPES * globals.MAX_NUMBER_TYPES)
                raise ConfigurationError(msg)


def _check_configuration_BC(BC):
    """ Check if everything is configured correctly

    Raises
    ------
    ConfigurationError
        if anything is wrong with the configuration
    """

    # All required parameters provided?
    bc_requirements = [CUBAExtension.BOX_FACES,
                       CUBAExtension.FIXED_GROUP]

    missing = [str(req) for req in bc_requirements
               if req not in BC.keys()]

    msg = ""
    if missing:
        msg = "Problem with BC component. "
        msg += "Missing: " + ', '.join(missing)

    if msg:
        # TODO throw unique exception that
        # users can catch and then try to fix
        # their configuration
        raise ConfigurationError(msg)

    # Correct format?
    if type(BC[CUBAExtension.BOX_FACES]) is not list:
        msg = "BOX_FACES must be given as list"
        raise ConfigurationError(msg)
    if type(BC[CUBAExtension.FIXED_GROUP]) is not list:
        msg = "FIXED_GROUP must be given as list"
        raise ConfigurationError(msg)

    # Each attribute defined for each material?
    if len(BC[CUBAExtension.BOX_FACES]) != 3:
        msg = "Need boundary condition information for all 3 directions."
        msg += "Only found {} entry.".format(len(BC[CUBAExtension.BOX_FACES]))
        raise ConfigurationError(msg)
    if len(BC[CUBAExtension.FIXED_GROUP]) != globals.MAX_NUMBER_TYPES:
        msg = "Need information about fixed groups for {} groups. ".\
            format(globals.MAX_NUMBER_TYPES)
        msg += "Only found {} entry.".\
            format(len(BC[CUBAExtension.FIXED_GROUP]))
        raise ConfigurationError(msg)


def _get_pair_style_liggghts(SP):
    """ get liggghts pair style command from CUBA

    supported styles are:
      - repulsion (hertz, with tangential friction)
      - cohesion (sjkr)

    """
    if CUBAExtension.PAIR_POTENTIALS in SP:
        potential_list = SP[CUBAExtension.PAIR_POTENTIALS]
    else:
        potential_list = ['repulsion']

    pairstyle_string = "pair_style "

    if "repulsion" in potential_list:
        pairstyle_string += "gran model hertz tangential history "

    if "cohesion" in potential_list:
        pairstyle_string += "cohesion sjkr"

    pairstyle_string += "\n"

    return pairstyle_string


def _get_boundary(BC, change_existing_boundary):
    """ get liggghts boundary command from BC

    The boundary command can be either fixed or periodic.

    >> BC[CUBAExtension.BOX_FACES] = ("periodic", "fixed", "periodic"]

    """

    error_message = ""
    boundary_command = ""
    if change_existing_boundary:
        boundary_command = "change_box all boundary"
    else:
        boundary_command = "boundary"

    # mapping of cuds-value to liggghts string
    mappings = {'periodic': 'p', 'fixed': 'f'}

    if len(BC[CUBAExtension.BOX_FACES]) != 3:
        error_message += "3 dimensions need to be given.\n"
    for b in BC[CUBAExtension.BOX_FACES]:
        if b in mappings:
            boundary_command += " {}".format(mappings[b])
        else:
            error_message += "'{}' is not supported\n"
    if error_message:
        message = ("Unsupported boundary was provided "
                   "BC[CUBAExtension.BOX_FACES] = {}\n"
                   "{}")
        ConfigurationError(message.format(
            BC[CUBAExtension.BOX_FACES], error_message))
    boundary_command += "\n"
    return boundary_command


def _get_box_planes(SP, BC):
    """ get liggghts box planes command from CUBAExtension

    """

    box_origin = SP[CUBAExtension.BOX_ORIGIN]
    box_vectors = SP[CUBAExtension.BOX_VECTORS]

    # origin is optional
    if not box_origin:
        box_origin = (0.0, 0.0, 0.0)
    plane_string = ""

    fmt_str = "fix {} all wall/gran model hertz " +\
              "tangential history primitive type 1 {} {:.16e}\n"
    if BC[CUBAExtension.BOX_FACES][0] is 'fixed':
        plane_string += fmt_str.format("xwall_low", "xplane", box_origin[0])
        plane_string += fmt_str.format("xwall_up", "xplane",
                                       box_origin[0]+(box_vectors[0][0]))
    if BC[CUBAExtension.BOX_FACES][1] is 'fixed':
        plane_string += fmt_str.format("ywall_low", "yplane", box_origin[1])
        plane_string += fmt_str.format("ywall_up", "yplane",
                                       box_origin[1]+(box_vectors[1][1]))
    if BC[CUBAExtension.BOX_FACES][2] is 'fixed':
        plane_string += fmt_str.format("zwall_low", "zplane", box_origin[2])
        plane_string += fmt_str.format("zwall_up", "zplane",
                                       box_origin[2]+(box_vectors[2][2]))
    return plane_string


def _get_material_data(SP):
    """ get liggghts material data command from CUBA

    supported data is:
      - Youngs modulus
      - Poissons ratio
      - Coefficient of restitution
      - Friction coefficient
      - Cohesion energy density

    """

    youngs_modulus = SP[CUBA.YOUNG_MODULUS]
    poisson_ratio = SP[CUBA.POISSON_RATIO]
    restitution_coeff = SP[CUBA.RESTITUTION_COEFFICIENT]
    friction_coeff = SP[CUBA.FRICTION_COEFFICIENT]

    if CUBAExtension.PAIR_POTENTIALS in SP:
        if "cohesion" in SP[CUBAExtension.PAIR_POTENTIALS]:
            cohe_energ_dens = SP[CUBA.COHESION_ENERGY_DENSITY]

    youngs_modulus_str = ""
    for i in range(0, globals.MAX_NUMBER_TYPES):
        youngs_modulus_str += str(youngs_modulus[i]) + " "

    poisson_ratio_str = ""
    for i in range(0, globals.MAX_NUMBER_TYPES):
        poisson_ratio_str += str(poisson_ratio[i]) + " "

    restitution_coeff_str = ""
    for i in range(0, globals.MAX_NUMBER_TYPES*globals.MAX_NUMBER_TYPES):
        restitution_coeff_str += str(restitution_coeff[i]) + " "

    friction_coeff_str = ""
    for i in range(0, globals.MAX_NUMBER_TYPES*globals.MAX_NUMBER_TYPES):
        friction_coeff_str += str(friction_coeff[i]) + " "

    if CUBAExtension.PAIR_POTENTIALS in SP:
        if "cohesion" in SP[CUBAExtension.PAIR_POTENTIALS]:
            cohe_energ_dens_str = ""
            for i in range(0,
                           globals.MAX_NUMBER_TYPES*globals.MAX_NUMBER_TYPES):
                cohe_energ_dens_str += str(cohe_energ_dens[i]) + " "

    matdata_string = ""
    matdata_string +=\
        "fix m1 all property/global youngsModulus peratomtype {}\n".\
        format(youngs_modulus_str)
    matdata_string +=\
        "fix m2 all property/global poissonsRatio peratomtype {}\n".\
        format(poisson_ratio_str)
    matdata_string +=\
        ("fix m3 all property/global" +
         " coefficientRestitution peratomtypepair {} {}\n").\
        format(globals.MAX_NUMBER_TYPES, restitution_coeff_str)
    matdata_string +=\
        ("fix m4 all property/global " +
         "coefficientFriction peratomtypepair {} {}\n").\
        format(globals.MAX_NUMBER_TYPES, friction_coeff_str)

    if CUBAExtension.PAIR_POTENTIALS in SP:
        if "cohesion" in SP[CUBAExtension.PAIR_POTENTIALS]:
            matdata_string +=\
                ("fix m5 all property/global " +
                 "cohesionEnergyDensity peratomtypepair {} {}\n").\
                format(globals.MAX_NUMBER_TYPES, cohe_energ_dens_str)

    return matdata_string


def _get_fixed_groups(BC):
    """ get information about which groups of particles are to be fixed
        (e.g. for fixed walls)

    """
    fixed_group_list = BC[CUBAExtension.FIXED_GROUP]
    command_str = ""
    for i in range(1, globals.MAX_NUMBER_TYPES+1):
        if fixed_group_list[i-1]:
            command_str += "group group_%i type %i\n" % (i, i)
            command_str += "fix %i group_%i setforce 0.0 0.0 0.0\n" % (i, i)

    return command_str


def _get_ext_forces(self):
    """ set infrastructure for externally applied force treatment

    """
    command_str = "fix df all property/atom df vector no no no 0.0 0.0 0.0\n"
    command_str += "variable dfx atom f_df[1]\n"
    command_str += "variable dfy atom f_df[2]\n"
    command_str += "variable dfz atom f_df[3]\n"
    command_str += "fix 6 all addforce v_dfx v_dfy v_dfz\n"

    return command_str


READ_DATA = """
# read from SimPhoNy-generated file
read_data {INPUT_DATAFILE}

"""


CONFIGURATION_RUN = """
# Run

timestep {TIME_STEP}

run {NUMBER_STEPS}
"""

WRITE_DATA = """

# write results to simphony-generated file
write_data {OUTPUT_DATAFILE}
"""

DEM_DUMMY = """
# It is heavily recommended to use 'neigh_modify delay 0' with granular
neigh_modify    delay 0

#  Pair granular with shear history requires newton pair off
newton          off

# Pair granular requires ghost atoms store velocity
communicate     single vel yes
"""
